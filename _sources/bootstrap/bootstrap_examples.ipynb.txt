{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Bootstrap Examples"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "_This setup code is required to run in an IPython notebook_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import warnings\n",
    "warnings.simplefilter('ignore')\n",
    "\n",
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn\n",
    "\n",
    "seaborn.set_style('darkgrid')\n",
    "plt.rc(\"figure\", figsize=(16, 6))\n",
    "plt.rc(\"savefig\", dpi=90)\n",
    "plt.rc(\"font\",family=\"sans-serif\")\n",
    "plt.rc(\"font\",size=14)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Sharpe Ratio"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The Sharpe Ratio is an important measure of return per unit of risk.  The example shows how to estimate the variance of the Sharpe Ratio and how to construct confidence intervals for the Sharpe Ratio using a long series of U.S. equity data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd\n",
    "\n",
    "import arch.data.frenchdata\n",
    "\n",
    "ff = arch.data.frenchdata.load()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The data set contains the Fama-French factors, including the excess market return."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "            Mkt-RF          SMB          HML           RF\n",
      "count  1109.000000  1109.000000  1109.000000  1109.000000\n",
      "mean      0.659946     0.206555     0.368864     0.274220\n",
      "std       5.327524     3.191132     3.482352     0.253377\n",
      "min     -29.130000   -16.870000   -13.280000    -0.060000\n",
      "25%      -1.970000    -1.560000    -1.320000     0.030000\n",
      "50%       1.020000     0.070000     0.140000     0.230000\n",
      "75%       3.610000     1.730000     1.740000     0.430000\n",
      "max      38.850000    36.700000    35.460000     1.350000\n"
     ]
    }
   ],
   "source": [
    "excess_market = ff.iloc[:, 0]\n",
    "print(ff.describe())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The next step is to construct a function that computes the Sharpe Ratio.  This function also return the annualized mean and annualized standard deviation which will allow the covariance matrix of these parameters to be estimated using the bootstrap."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "def sharpe_ratio(x):\n",
    "    mu, sigma = 12 * x.mean(), np.sqrt(12 * x.var())\n",
    "    values = np.array([mu, sigma, mu / sigma]).squeeze()\n",
    "    index = ['mu', 'sigma', 'SR']\n",
    "    return pd.Series(values, index=index)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The function can be called directly on the data to show full sample estimates."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "mu        7.919351\n",
       "sigma    18.455084\n",
       "SR        0.429115\n",
       "dtype: float64"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "params = sharpe_ratio(excess_market)\n",
    "params"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Reproducibility\n",
    "\n",
    "All bootstraps accept the keyword argument `random_state` which can contain a NumPy `RandomState` instance. This allows the same pseudo random values to be used across multiple runs."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### _Warning_\n",
    "\n",
    "_The bootstrap chosen must be appropriate for the data.  Squared returns are serially correlated, and so a time-series bootstrap is required._"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Bootstraps are initialized with any bootstrap specific parameters and the data to be used in the bootstrap.  Here the `12` is the average window length in the Stationary Bootstrap, and the next input is the data to be bootstrapped."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAA6wAAAF9CAYAAAAAxuXnAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjMuNCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8QVMy6AAAACXBIWXMAAAsTAAALEwEAmpwYAAArvUlEQVR4nO3de7RWdZ0/8PfxcBeQ2yOpuAaxwFJBUEMEIsl0CpsEy2FyiXkNW7paYiBa5qTIRUezQSOvlaaWmVKCaY3VLJVmVGKaQQ2VifFCxuGmchG5nN8frc6vE6Bc9jlnn8PrtRZr8ey9n8/z2Wt93ey3+7v3rqqtra0NAAAAlMxeTd0AAAAAbIvACgAAQCkJrAAAAJSSwAoAAEApCawAAACUksAKAABAKQmsAAAAlFKrpm4AAPYkL730Um666ab87ne/S01NTfbZZ5/07t07gwcPzoUXXpgkOf300/PUU0/Vfadt27b5u7/7u5xyyikZN25c9trL/28GYM8gsAJAI1mwYEHGjRuXfffdN2PGjEnPnj3zpz/9Kc8++2xuueWWusCaJJVKJRMnTkySrFq1KnPmzMm0adOyatWqXHTRRU21CwDQqKpqa2trm7oJANgTnHfeefnd736XRx55JF27dq23bvny5enRo0eSP19hrampySOPPFK3fsOGDfnEJz6R1atX5+mnn051dXWj9g4ATcGcIgBoJC+//HIOPvjgrcJqkrqwuj1t27bNYYcdlrVr12bFihUN1SIAlIrACgCN5IADDsjzzz+f3//+97v0/ddeey1VVVXp3LlzwZ0BQDm5hxUAGsk555yTs846K6NHj85hhx2Wo446KoMHD86QIUPStm3bettu2bIlK1euTJKsXr06999/fxYuXJiPfvSjadeuXVO0DwCNzj2sANCIfvvb3+bWW2/Nb37zm6xfvz5J0rFjx1x22WU55ZRTkmz9lOC/+NjHPparr756m1OKAaAlcoUVABrRoEGDMmvWrGzcuDGLFy/Or371q9x+++257LLLsv/++2fIkCFJkv322y9Tp05NbW1tXn755dx8881ZtWqVq6sA7FHcwwoATaB169Y55JBDcv7552fmzJlJkp/+9Kd169u1a5djjz02Q4cOzT/90z/l1ltvzX//93/n+uuvb6qWAaDRCawA0MT69++fJFm2bNl2t/nABz6Qk08+Offee2+WLl3aWK0BQJMSWAGgkfzmN7/Jli1btlr+7//+70mSPn36vOv3zz777GzatCl33HFHg/QHAGXjHlYAaCRXX3111q1bl+OPPz4HH3xwtmzZkueeey4/+clP0qVLl5xxxhnv+v0+ffrkox/9aO6///588YtfTLdu3RqpcwBoGq6wAkAjmTRpUo499tg88cQTmTFjRq6++uo8+eST+dSnPpX7778/vXr1es8aZ599dtavX58777yzEToGgKbltTYAAACUkiusAAAAlJLACgAAQCkJrAAAAJSSwAoAAEApCawAAACUUrN4D+uWLVuyefPuP8y4urqqkDrQFIxfmitjl+bM+KU5M35pTlq3rt7m8mYRWDdvrs3q1et2u06XLh0KqQNNwfiluTJ2ac6MX5oz45fmpFLptM3lpgQDAABQSgIrAAAApSSwAgAAUEoCKwAAAKUksAIAAFBKAisAAACltEOB9eabb84pp5ySQYMG5Zhjjsn48ePzwgsv1NumtrY2M2fOzLBhw9K/f/+cfvrpefHFF+tt88Ybb2TixIk58sgjc+SRR2bixIl58803i9sbAAAAWowdCqxPPfVUPve5z+UHP/hBvve976W6ujpnnnlmVq9eXbfNrbfemjvuuCOXX3557r///nTr1i1nnnlm1qxZU7fNxRdfnOeeey633XZbbrvttjz33HOZNGlS4TsFAABA81dVW1tbu7NfWrt2bY466qjcdNNNGTlyZGprazN8+PCcdtppOf/885Mkb7/9doYMGZJLLrkkY8eOzeLFi/PJT34y99xzT4488sgkyTPPPJPTTjstP/vZz9KnT5/t/t7GjZsLeemxlyfTnBm/NFfGLs2Z8UtzZvzSnFQqnba5fJfuYV27dm22bNmSzp07J0leffXV1NTUZOjQoXXbtGvXLkcffXQWLFiQJFmwYEE6dOiQQYMG1W1z5JFHpkOHDnXbAAAAwF+02pUvXX311fngBz+YgQMHJklqamqSJD169Ki3Xffu3bNs2bIkyfLly9OtW7dUVVXVra+qqkq3bt2yfPnyd/296uqqdOnSYVda/Zs6exVSB5qC8UtzZezSnBm/NGfGLy3BTgfWadOmZf78+bn33ntTXV3dED1tZfPmWlOC2eMZvzRXxi7NmfFLc2b80pwUMiV46tSpmTt3br73ve/lwAMP/KvilSTZ6krpihUr6q669ujRIytXrsxf3zJbW1ublStXbnVlFgAAAHb4CuuUKVPys5/9LHfeeWcOPvjgeut69eqVSqWSefPmpX///kmSDRs25Jlnnql7CvDAgQOzbt26LFiwoO4+1gULFmTdunV1U4sB4G917Nw+7dvu0h0s27V+w6aseXN9oTUBgOLt0BnA17/+9fzkJz/JTTfdlM6dO9fds9qhQ4fsvffeqaqqyrhx43LzzTenT58+6d27d2bNmpUOHTrkpJNOSpIcfPDBGT58eK644opceeWVSZIrrrgixx133Ls+IRiAPVv7tq3Se/LcQmsumT4qa957MwCgie1QYL3nnnuSJJ///OfrLb/gggty4YUXJknOPffcbNiwIVdeeWXeeOONDBgwIHfccUc6duxYt/11112Xq666KmeffXaSZOTIkfna175WxH4AAADQwuzSe1gbm/ewgvFL87W7Y7dS6dQgV1hrat4qtCYtk2MvzZnxS3NS6HtYAQAAoKEJrAAAAJSSwAoAAEApCawAAACUksAKAABAKQmsAAAAlJLACgAAQCkJrAAAAJSSwAoAAEApCawAAACUksAKAABAKQmsAAAAlFKrpm4AgKbVsXP7tG9b3D8H6zdsypo31xdWryG8vXFzKpVOhdVrDvsMAM2RwAqwh2vftlV6T55bWL0l00dlTWHVGka71tV73D4DQHNkSjAAAAClJLACAABQSgIrAAAApSSwAgAAUEoCKwAAAKUksAIAAFBKAisAAAClJLACAABQSgIrAAAApSSwAgAAUEoCKwAAAKUksAIAAFBKAisAAAClJLACAABQSq12ZKOnn346t99+e5599tksW7Ys06ZNy5gxY+rW9+vXb5vf+9znPpcrrrgiSTJ58uQ8+OCD9dYPGDAg99133672DgAAQAu2Q4F13bp16du3b04++eRccsklW61/4okn6n1euHBhxo8fn0984hP1lh977LG55ppr6j63bt16V3oGAABgD7BDgXXEiBEZMWJEkuTSSy/dan2lUqn3+bHHHkvv3r3z4Q9/uN7yNm3abLUtAAAAbEvh97CuXbs2c+fOzamnnrrVuvnz52fIkCE58cQT89WvfjUrVqwo+ucBAABoIXboCuvOmDNnTjZu3JjRo0fXWz58+PB8/OMfT69evfLaa6/lhhtuyBlnnJEHHnggbdq0edea1dVV6dKlw273Vl29VyF1oCkYvzQnfz1W94Sx+/bGzalUOhVar7qwauyOPWH80nIZv7QEhQfW++67Lx/72MfSrVu3estHjRpV9/d+/frl0EMPzciRI/PrX/86J5xwwrvW3Ly5NqtXr9vt3rp06VBIHWgKxi8Npcig9Rd/PVZ3d+w2RH9Fa9e6Or0nzy2s3pLpo1JT81Zh9dh1jr00Z8Yvzcn2/r0vdErw888/n4ULF25zOvDf6tmzZ3r27JklS5YU2QIAAAAtRKGB9Yc//GF69eqVY4899j23XblyZZYtW5Z99923yBYAAABoIXZoSvDatWvz8ssvJ0m2bNmSpUuX5vnnn88+++yT/fffP0myfv36PPTQQznnnHNSVVW11fdvvPHGnHDCCalUKnnttddy/fXXp1u3bjn++OML3iUAAABagh0KrAsXLsy4cePqPs+cOTMzZ87M6NGjM3369CTJww8/nPXr12fMmDFbfb+6ujovvPBCZs+enbfeeiuVSiWDBw/ODTfckI4dOxa0KwCUwbYeQNQc7kMFAMpnhwLr4MGDs2jRonfd5pRTTskpp5yyzXXt2rXL7bffvvPdAdDsNMQDiACAPVPh72EFAACAIgisAAAAlJLACgAAQCkJrAAAAJSSwAoAAEApCawAAACUksAKAABAKQmsAAAAlJLACgAAQCkJrAAAAJSSwAoAAEApCawAAACUUqumbgCAndOxc/u0b+vwDQC0fM54AJqZ9m1bpffkuYXVWzJ9VGG1AACKZEowAAAApSSwAgAAUEoCKwAAAKUksAIAAFBKAisAAAClJLACAABQSgIrAAAApSSwAgAAUEoCKwAAAKUksAIAAFBKAisAAAClJLACAABQSq2augEAoL63N25OpdKp0JrrN2zKmjfXF1oTABqawAoAJdOudXV6T55baM0l00dlTaEVAaDhmRIMAABAKe1QYH366aczfvz4DB8+PP369csDDzxQb/3kyZPTr1+/en9OPfXUetu88847ueqqqzJ48OAcccQRGT9+fF5//fXi9gQAAIAWZYcC67p169K3b9985StfSbt27ba5zbHHHpsnnnii7s8tt9xSb/3VV1+dRx99NNdff33uvvvurF27Nl/4wheyefPm3d8LAAAAWpwduod1xIgRGTFiRJLk0ksv3eY2bdq0SaVS2ea6t956Kz/+8Y8zderUDB06NElyzTXX5Ljjjsu8efMyfPjwXekdAACAFqywhy7Nnz8/Q4YMSefOnXP00UfnoosuSvfu3ZMkCxcuzMaNGzNs2LC67ffbb78cfPDBWbBgwXsG1urqqnTp0mG3e6yu3quQOtAUjF9gdzmG7DzHXpoz45eWoJDAOnz48Hz84x9Pr1698tprr+WGG27IGWeckQceeCBt2rTJ8uXLU11dna5du9b7Xvfu3bN8+fL3rL95c21Wr16323126dKhkDrQFIxf/qLo152w53AM2XmOvTRnxi/NyfbObwoJrKNGjar7e79+/XLooYdm5MiR+fWvf50TTjihiJ8AAABgD9Mgr7Xp2bNnevbsmSVLliRJevTokc2bN2fVqlX1tluxYkV69OjREC0AAADQzDVIYF25cmWWLVuWfffdN0ly2GGHpXXr1nnyySfrtnn99dezePHiDBw4sCFaAAAAoJnboSnBa9euzcsvv5wk2bJlS5YuXZrnn38+++yzT/bZZ5/ceOONOeGEE1KpVPLaa6/l+uuvT7du3XL88ccnSTp16pRTTjkl1157bbp3754uXbpk2rRp6devX4499tiG2zsAAACarR0KrAsXLsy4cePqPs+cOTMzZ87M6NGj88///M954YUXMnv27Lz11lupVCoZPHhwbrjhhnTs2LHuO1/5ylfSqlWrXHTRRXn77bczZMiQXHPNNamuri5+rwAAAGj2diiwDh48OIsWLdru+ttvv/09a7Rp0yaXX355Lr/88h3vDgAoxNsbNxf6hOn1GzZlzZvrC6sHANtS2HtYAYDyate6Or0nzy2s3pLpo7KmsGoAsG0N8tAlAAAA2F0CKwAAAKUksAIAAFBKAisAAAClJLACAABQSgIrAAAApSSwAgAAUEoCKwAAAKUksAIAAFBKrZq6AYCWrGPn9mnf1qEWAGBXOIsCaEDt27ZK78lzC625ZPqoQusBAJSVKcEAAACUksAKAABAKQmsAAAAlJLACgAAQCkJrAAAAJSSwAoAAEApCawAAACUksAKAABAKQmsAAAAlJLACgAAQCkJrAAAAJSSwAoAAEApCawAAACUksAKAABAKQmsAAAAlJLACgAAQCntUGB9+umnM378+AwfPjz9+vXLAw88ULdu48aNufbaa/OpT30qRxxxRIYNG5aLL744S5curVfj9NNPT79+/er9ueiii4rdGwAAAFqMVjuy0bp169K3b9+cfPLJueSSS+qte/vtt/Pcc8/l/PPPzyGHHJI1a9Zk+vTpOeecc/LTn/40rVr9/58YM2ZMJkyYUPe5Xbt2Be0GAAAALc0OBdYRI0ZkxIgRSZJLL7203rpOnTrlO9/5Tr1lV155ZUaNGpXFixenX79+dcvbt2+fSqWyuz0DAACwB2iQe1jXrFmTJNlnn33qLZ87d24GDx6cUaNGZcaMGXXbAQAAwN/aoSusO+Odd97J9OnTc9xxx+V973tf3fKTTjop+++/f/bdd9+89NJLue6667Jo0aLccccd71mzuroqXbp02O3eqqv3KqQONAXjFyibPeGY5NhLc2b80hIUGlg3bdqUiRMn5q233sqsWbPqrfvHf/zHur/369cvBx54YD772c/m2WefzaGHHvqudTdvrs3q1et2u78uXToUUgeagvHbPFUqnZq6BWgwe8IxybGX5sz4pTnZ3jlTYVOCN23alAkTJmTRokX57ne/m65du77r9ocddliqq6vzf//3f0W1AAAAQAtSyBXWjRs3ZsKECXnhhRdy11137dCDlV544YVs3rzZQ5gAAADYph0KrGvXrs3LL7+cJNmyZUuWLl2a559/Pvvss0/23XfffOlLX8r//M//5Nvf/naqqqpSU1OT5M9PEG7Xrl1efvnl/PSnP82IESPStWvXLF68ONOnT8+HPvShDBo0qOH2DgAAgGZrhwLrwoULM27cuLrPM2fOzMyZMzN69OhccMEFeeyxx5L8+T2rf23atGkZM2ZMWrdunf/4j//IXXfdlbVr12a//fbLiBEjcsEFF6S6urrA3QEAAKCl2KHAOnjw4CxatGi7699tXZLst99++f73v79znQEAALBHa5D3sAIAAMDuKvw9rADNWcfO7dO+rUMjAEAZOCsD+Cvt27ZK78lzC6u3ZPqowmoBAOxpTAkGAACglARWAAAASklgBQAAoJQEVgAAAEpJYAUAAKCUBFYAAABKSWAFAACglARWAAAASklgBQAAoJRaNXUDAEDz8/bGzalUOhVWb/2GTVnz5vrC6gHQMgisAMBOa9e6Or0nzy2s3pLpo7KmsGoAtBSmBAMAAFBKAisAAAClJLACAABQSgIrAAAApSSwAgAAUEoCKwAAAKUksAIAAFBKAisAAAClJLACAABQSgIrAAAApSSwAgAAUEoCKwAAAKUksAIAAFBKAisAAACltEOB9emnn8748eMzfPjw9OvXLw888EC99bW1tZk5c2aGDRuW/v375/TTT8+LL75Yb5s33ngjEydOzJFHHpkjjzwyEydOzJtvvlncngAAANCitNqRjdatW5e+ffvm5JNPziWXXLLV+ltvvTV33HFHpk+fnoMOOig33XRTzjzzzDzyyCPp2LFjkuTiiy/OH//4x9x2221Jkq9+9auZNGlSvv3tbxe4O8CepmPn9mnfdocOZQAANDM7dJY3YsSIjBgxIkly6aWX1ltXW1ubO++8M+edd15OPPHEJMmMGTMyZMiQzJkzJ2PHjs3ixYvz+OOP55577snAgQOTJF//+tdz2mmn5X//93/Tp0+fIvcJ2IO0b9sqvSfPLazekumjCqsFAMDu2e17WF999dXU1NRk6NChdcvatWuXo48+OgsWLEiSLFiwIB06dMigQYPqtjnyyCPToUOHum0AAADgr+32PLqampokSY8ePeot7969e5YtW5YkWb58ebp165aqqqq69VVVVenWrVuWL1/+nr9RXV2VLl067G6rqa7eq5A60BSMX6ClK+MxzrGX5sz4pSVoFjd+bd5cm9Wr1+12nS5dOhRSB5qC8bttlUqnpm4BKEjRx7ii7nHfa6/qJMn6DZuy5s31u10PGotzB5qT7Z3T7fZRvFKpJPnzVdT999+/bvmKFSvqrrr26NEjK1euTG1tbd1V1tra2qxcuXKrK7MAAEVoiHvc1xRWDYAdsduBtVevXqlUKpk3b1769++fJNmwYUOeeeaZTJo0KUkycODArFu3LgsWLKi7j3XBggVZt25d3UOYAIA919sbN5sxAcBWdiiwrl27Ni+//HKSZMuWLVm6dGmef/757LPPPtl///0zbty43HzzzenTp0969+6dWbNmpUOHDjnppJOSJAcffHCGDx+eK664IldeeWWS5Iorrshxxx3nCcEAQNq1ri70amjiqd8ALcEOBdaFCxdm3LhxdZ9nzpyZmTNnZvTo0Zk+fXrOPffcbNiwIVdeeWXeeOONDBgwIHfccUfdO1iT5LrrrstVV12Vs88+O0kycuTIfO1rXyt4dwAAAGgpdiiwDh48OIsWLdru+qqqqlx44YW58MILt7vNPvvsk3/5l3/Z+Q4BAADYI+32e1gBAACgIQisAAAAlJLACgAAQCkJrAAAAJSSwAoAAEAp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6NGjM2fOnNx0001ZvHhxvvzlLzdy57BzWsw9rJ/97GfTr1+/TJkypW7ZCSeckBNPPDEXX3zxVttfe+21+cUvfpGf//zndcu+8pWv5KWXXsoPf/jDRukZ/mJnx++2fOYzn8lRRx2VyZMnN1SbsJVdHbsXXHBBDjnkkNTW1ubRRx/NnDlzGqNdqGdnx+8TTzyRL33pS/nFL36Rbt26NWarsJWdHb+33357vv/97+dXv/pV3bIf//jHmTJlShYsWNAoPcOuaBFXWN955508++yzGTp0aL3lQ4cO3e5/gP/1X/+11fbDhg3LwoULs3HjxgbrFf7WrozfbVm7dm06d+5cdHuwXbs6du++++4sX748559/fkO3CNu1K+P33/7t33L44Yfnu9/9bj7ykY/khBNOyJQpU7J27drGaBnq7Mr4HTRoUGpqavLLX/4ytbW1WblyZR5++OF85CMfaYyWYZe1iMC6atWqbN68OT169Ki3vHv37tudl798+fJ079693rIePXpk06ZNWbVqVYP1Cn9rV8bv37r77rvz+uuv59Of/nRDtAjbtCtjd9GiRbnpppty7bXXprq6ujHahG3alfH7yiuvZP78+fn973+fmTNn5vLLL8/jjz+eSy+9tDFahjq7Mn4HDhyY66+/Pl/+8pdz2GGHZciQIamtrc2MGTMao2XYZS0isMKe7NFHH80111yT6667zjuNKbV33nknF110USZNmpQDDzywqduBnVZbW5uqqqpcd911GTBgQIYPH57LL788jz76aJYvX97U7cG7eumll3LVVVfli1/8Yn784x/ntttuS01NTb72ta81dWvwrlo1dQNF6Nq1a6qrq7f6x2LFihWpVCrb/E6PHj2yYsWKesuWL1+eVq1apWvXrg3WK/ytXRm/f/HII4/kkksuyYwZMzJy5MiGbBO2srNjd9myZVm8eHEuu+yyXHbZZUmSLVu2pLa2Nh/60Idyyy23ZNiwYY3SO+zKsbdSqaRnz57p1KlT3bKDDz44SbJ06dKtrnZBQ9mV8XvzzTenf//+Oeecc5IkhxxySNq3b5/TTjstEyZMyPve974G7xt2RYu4wtqmTZsceuihmTdvXr3l8+bNy8CBA7f5nSOOOGKb2x922GFp3bp1g/UKf2tXxm/y56cDTpo0KdOmTcvf//3fN3SbsJWdHbs9e/bMQw89lNmzZ9f9GTt2bP7u7/6u7gmX0Fh25dg7aNCgLFu2rN49q0uWLEkSM1xoVLsyft9+++2tbsX4y+ctW7Y0TKNQgBYRWJPkzDPPzIMPPpgf/ehHWbx4caZMmZJly5Zl7NixSZJJkyZl0qRJdduPHTs2f/rTn3L11Vdn8eLF+dGPfpQHH3wwZ511VlPtAnuwnR2/c+fOzcSJE3PxxRfn6KOPTk1NTWpqarJ69eom2gP2VDszdlu3bp2+ffvW+9O9e/e0adMmffv2zd57792Uu8IeaGePvSeddFK6dOmSSy+9NC+++GLmz5+fq6++OieeeOJWz8WAhraz4/e4447LY489lnvuuafufuwpU6bk0EMPzf77799UuwHvqUVMCU6ST37yk1m1alVmzZqVZcuWpW/fvrnlllvq/o/nH//4x3rbH3jggbnlllsybdq03Hvvvdl3333zla98JSeeeGJTtM8ebmfH7w9+8INs2rQpU6dOzdSpU+uWf/jDH85dd93VqL2zZ9vZsQtlsrPjd++99853vvOdTJkyJZ/5zGfSuXPnHH/88Tv8+jEo0s6O3zFjxmTt2rW5++67M2PGjHTq1CmDBw/OxIkTm6J92GEt5j2sAAAAtCwtZkowAAAALYvACgAAQCkJrAAAAJSSwAoAAEApCawAAACUksAKAABAKQmsAAAAlJLACgAAQCkJrAAAAJTS/wMDyFGzDLJ3DAAAAABJRU5ErkJggg==\n",
      "text/plain": [
       "<Figure size 1152x432 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "from arch.bootstrap import StationaryBootstrap\n",
    "# Initialize with entropy from random.org\n",
    "entropy = [877788388, 418255226, 989657335, 69307515]\n",
    "rs = np.random.RandomState(entropy)\n",
    "\n",
    "bs = StationaryBootstrap(12, excess_market, random_state=rs)\n",
    "results = bs.apply(sharpe_ratio, 2500)\n",
    "SR = pd.DataFrame(results[:, -1:], columns=['SR'])\n",
    "fig = SR.hist(bins=40)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "             mu     sigma        SR\n",
      "mu     3.835234 -0.700250  0.222532\n",
      "sigma -0.700250  3.517844 -0.119008\n",
      "SR     0.222532 -0.119008  0.014912\n",
      "\n",
      "\n",
      "mu       1.958375\n",
      "sigma    1.875592\n",
      "SR       0.122114\n",
      "Name: Std Errors, dtype: float64\n"
     ]
    }
   ],
   "source": [
    "cov = bs.cov(sharpe_ratio, 1000)\n",
    "cov = pd.DataFrame(cov, index=params.index, columns=params.index)\n",
    "print(cov)\n",
    "se = pd.Series(np.sqrt(np.diag(cov)), index=params.index)\n",
    "se.name = 'Std Errors'\n",
    "print('\\n')\n",
    "print(se)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "              mu      sigma        SR\n",
      "Lower   4.319805  14.559092  0.186293\n",
      "Upper  12.004185  21.517835  0.660455\n"
     ]
    }
   ],
   "source": [
    "ci = bs.conf_int(sharpe_ratio, 1000, method='basic')\n",
    "ci = pd.DataFrame(ci, index=['Lower', 'Upper'], columns=params.index)\n",
    "print(ci)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Alternative confidence intervals can be computed using a variety of methods.  Setting `reuse=True` allows the previous bootstrap results to be used when constructing confidence intervals using alternative methods."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "              mu      sigma        SR\n",
      "Lower   3.834517  15.392333  0.197774\n",
      "Upper  11.518896  22.351076  0.671937\n"
     ]
    }
   ],
   "source": [
    "ci = bs.conf_int(sharpe_ratio, 1000, method='percentile', reuse=True)\n",
    "ci = pd.DataFrame(ci, index=['Lower', 'Upper'], columns=params.index)\n",
    "print(ci)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Optimal Block Length Estimation\n",
    "\n",
    "The function `optimal_block_length` can be used to estimate the optimal block lengths for the Stationary and Circular bootstraps. Here we use the squared market return since the Sharpe ratio depends on the mean and the variance, and the autocorrelation in the squares is stronger than in the returns."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "        stationary   circular\n",
      "Mkt-RF   47.766787  54.679322\n"
     ]
    }
   ],
   "source": [
    "from arch.bootstrap import optimal_block_length\n",
    "opt = optimal_block_length(excess_market ** 2)\n",
    "print(opt)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can repeat the analysis above using the estimated optimal block length.  Here we see that the extremes appear to be slightly more extreme."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAA6wAAAF9CAYAAAAAxuXnAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjMuNCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8QVMy6AAAACXBIWXMAAAsTAAALEwEAmpwYAAArwUlEQVR4nO3df5RXdZ0/8Oc4gAPyGz6Sv84SFlgqCGiEQCSZVtgWWK5bR8yfaUdOR0xEzdwUBTTNFo31Z6WpZaaUYlprtUelXZXYdlFDZWNVWGMAURl+CMN8/+jbrLOADnCZuQyPxzlzDp977+f1ed1z3tz5POfe+75VDQ0NDQEAAICS2aO1GwAAAIAtEVgBAAAoJYEVAACAUhJYAQAAKCWBFQAAgFISWAEAACglgRUAAIBSatfaDQDA7uTFF1/MDTfckD/84Q+pra1Nt27d0rdv3wwbNiwTJ05Mkpx00kl58sknG9+z55575m/+5m9y/PHHZ8KECdljD39vBmD3ILACQAuZP39+JkyYkL333jvjx49Pnz598uc//znPPPNMbrrppsbAmiSVSiXnn39+kuS1117Lgw8+mGnTpuW1117Lueee21q7AAAtqqqhoaGhtZsAgN3BmWeemT/84Q95+OGH06NHjybrli9fnt69eyf5yxnW2traPPzww43r169fn09+8pNZtWpVnnrqqVRXV7do7wDQGlxTBAAt5KWXXsqBBx64WVhN0hhWt2bPPffMIYcckrq6uqxYsWJntQgApSKwAkAL2W+//fLcc8/lj3/843a9f8mSJamqqkrXrl0L7gwAysk9rADQQk4//fSceuqpGTduXA455JAcfvjhGTZsWIYPH54999yzybabNm3KypUrkySrVq3KvffemwULFuSjH/1oampqWqN9AGhx7mEFgBb0+9//PjfffHN+97vfZe3atUmSzp0756KLLsrxxx+fZPNZgv/qYx/7WK644ootXlIMAG2RM6wA0IKGDBmSWbNmZcOGDVm0aFF+85vf5NZbb81FF12UfffdN8OHD0+S7LPPPrnyyivT0NCQl156KTfeeGNee+01Z1cB2K24hxUAWkH79u1z0EEH5eyzz87MmTOTJD//+c8b19fU1OTII4/MiBEj8vd///e5+eab8x//8R+59tprW6tlAGhxAisAtLKBAwcmSZYtW7bVbd7//vfns5/9bO6+++4sXbq0pVoDgFYlsAJAC/nd736XTZs2bbb8X/7lX5Ik/fr1e8f3n3baadm4cWNuu+22ndIfAJSNe1gBoIVcccUVWbNmTY4++ugceOCB2bRpU5599tn87Gc/S/fu3XPyySe/4/v79euXj370o7n33nvzla98JT179myhzgGgdTjDCgAtZPLkyTnyyCPz+OOPZ8aMGbniiivyxBNP5NOf/nTuvffe7L///u9a47TTTsvatWtz++23t0DHANC6PNYGAACAUnKGFQAAgFISWAEAACglgRUAAIBSElgBAAAoJYEVAACAUtolnsO6adOm1NcXN5lxdXVVofWgtRjLtAXGMW2FsUxbYSzTGtq3r97i8l0isNbXN2TVqjWF1evevVOh9aC1GMu0BcYxbYWxTFthLNMaKpUuW1zukmAAAABKSWAFAACglARWAAAASklgBQAAoJQEVgAAAEpJYAUAAKCUBFYAAABKSWAFAACglARWAAAASqlZgfXGG2/M8ccfnyFDhuTDH/5wzjrrrDz//PNNtmloaMjMmTMzcuTIDBw4MCeddFJeeOGFJtu8/vrrOf/88zN06NAMHTo0559/ft54443i9gYAAIA2o1mB9cknn8wXvvCF/OhHP8oPfvCDVFdX55RTTsmqVasat7n55ptz22235ZJLLsm9996bnj175pRTTsnq1asbtznvvPPy7LPP5pZbbsktt9ySZ599NpMnTy58pwAAANj1VTU0NDRs65vq6upy+OGH54YbbsiYMWPS0NCQUaNG5Ytf/GLOPvvsJMm6desyfPjwXHDBBTnxxBOzaNGifOpTn8pdd92VoUOHJkmefvrpfPGLX8wvfvGL9OvXb6uft2FDfVatWrOdu7i57t07FVoPWouxTFtgHNNWGMu0FcYyraFS6bLF5dt1D2tdXV02bdqUrl27JkleeeWV1NbWZsSIEY3b1NTU5Igjjsj8+fOTJPPnz0+nTp0yZMiQxm2GDh2aTp06NW4DAAAAf9Vue950xRVX5AMf+EAGDx6cJKmtrU2S9O7du8l2vXr1yrJly5Iky5cvT8+ePVNVVdW4vqqqKj179szy5cvf8fOqq6vSvXun7Wl1K/X2KLQetBZjmbagNcZxfZKa9tWF1Vu3oT7FVWNX5ZhMW2EsUybbHFinTZuWefPm5e677051dcv8eq6vb3BJMGyBsUxb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+eab+elPf5orr7wyI0aMSJJcddVVOeqoozJ37tyMGjVqe3oHAACgDSvsHtZ58+Zl+PDhOfbYY/P1r389K1asaFy3YMGCbNiwISNHjmxcts8+++TAAw/M/Pnzi2oBAACANqSQx9qMGjUqH//4x7P//vtnyZIlue6663LyySfnvvvuS4cOHbJ8+fJUV1enR48eTd7Xq1evLF++/F3rV1dXpXv3TkW0+v/r7VFoPWgtxnL51ecvjxOBtsjxpynHZNoKY5kyKSSwjh07tvHfAwYMyMEHH5wxY8bkt7/9bY455pgdrl9f35BVq9bscJ2/6t69U6H1oLUYy+VXqXQp9NmXyV+efwll4PjTlGMybYWxTGuoVLpscflOeaxNnz590qdPnyxevDhJ0rt379TX1+e1115rst2KFSvSu3fvndECAAAAu7idElhXrlyZZcuWZe+9906SHHLIIWnfvn2eeOKJxm1effXVLFq0KIMHD94ZLQAAALCLa9YlwXV1dXnppZeSJJs2bcrSpUvz3HPPpVu3bunWrVuuv/76HHPMMalUKlmyZEmuvfba9OzZM0cffXSSpEuXLjn++ONz9dVXp1evXunevXumTZuWAQMG5Mgjj9x5ewcAAMAuq1mBdcGCBZkwYULj65kzZ2bmzJkZN25c/uEf/iHPP/98Zs+enTfffDOVSiXDhg3Lddddl86dOze+5+KLL067du1y7rnnZt26dRk+fHiuuuqqVFebjAQAAIDNNSuwDhs2LAsXLtzq+ltvvfVda3To0CGXXHJJLrnkkuZ3BwAAwG5rp9zDCgAAADtKYAUAAKCUBFYAAABKSWAFAACglARWAAAASklgBQAAoJQEVgAAAEpJYAUAAKCUBFYAAABKSWAFAACglARWAAAASklgBQAAoJQEVgAAAEpJYAUAAKCUBFYAAABKSWAFAACglARWAAAASklgBQAAoJQEVgAAAEpJYAUAAKCUBFYAAABKSWAFAACglARWAAAASklgBQAAoJQEVgAAAEpJYAUAAKCUBFYAAABKSWAFAACglJoVWJ966qmcddZZGTVqVAYMGJD77ruvcd2GDRty9dVX59Of/nQOO+ywjBw5Muedd16WLl3apMZJJ52UAQMGNPk599xzi90bAAAA2ox2zdlozZo16d+/fz772c/mggsuaLJu3bp1efbZZ3P22WfnoIMOyurVqzN9+vScfvrp+fnPf5527f73I8aPH59JkyY1vq6pqSloNwAAAGhrmhVYR48endGjRydJLrzwwibrunTpku9973tNll122WUZO3ZsFi1alAEDBjQu79ixYyqVyo72DAAAwG5gp9zDunr16iRJt27dmiyfM2dOhg0blrFjx2bGjBmN2wEAAMD/1awzrNvirbfeyvTp03PUUUflPe95T+Py4447Lvvuu2/23nvvvPjii7nmmmuycOHC3Hbbbe9as7q6Kt27dyqsx+rqPQqtB63FWAZak+NPU47JtBXGMmVSaGDduHFjzj///Lz55puZNWtWk3V/93d/1/jvAQMG5IADDsjnP//5PPPMMzn44IPfsW59fUNWrVpTWJ/du3cqtB60FmO5/CqVLq3dAuw0jj9NOSbTVhjLtIatfWcq7JLgjRs3ZtKkSVm4cGG+//3vp0ePHu+4/SGHHJLq6ur893//d1EtAAAA0IYUcoZ1w4YNmTRpUp5//vnccccdzZpY6fnnn099fb1JmAAAANiiZgXWurq6vPTSS0mSTZs2ZenSpXnuuefSrVu37L333vnqV7+a//zP/8w//dM/paqqKrW1tUn+MoNwTU1NXnrppfz85z/P6NGj06NHjyxatCjTp0/PBz/4wQwZMmTn7R0AAAC7rGYF1gULFmTChAmNr2fOnJmZM2dm3LhxOeecc/Loo48m+ctzVt9u2rRpGT9+fNq3b59//dd/zR133JG6urrss88+GT16dM4555xUV1cXuDsAAAC0Fc0KrMOGDcvChQu3uv6d1iXJPvvskx/+8Ifb1hkAAAC7tcIfawMAtH3rNtQXOgv22vUbs/qNtYXVA6BtEFgBgG1W0746fafMKaze4uljs7qwagC0FYU91gYAAACKJLACAABQSgIrAAAApSSwAgAAUEoCKwAAAKUksAIAAFBKAisAAAClJLACAABQSgIrAAAApSSwAgAAUEoCKwAAAKUksAIAAFBKAisAAAClJLACAABQSgIrAAAApSSwAgAAUEoCKwAAAKXUrrUbACiTzl07puOeDo0AAGXgWxnA23Tcs136TplTWL3F08cWVgsAYHfjkmAAAABKSWAFAACglARWAAAASsk9rABAq1u3oT6VSpdCa65dvzGr31hbaE0AWpbACgC0upr21YVOeJb8ZdKz1YVWBKCluSQYAACAUhJYAQAAKKVmBdannnoqZ511VkaNGpUBAwbkvvvua7K+oaEhM2fOzMiRIzNw4MCcdNJJeeGFF5ps8/rrr+f888/P0KFDM3To0Jx//vl54403itsTAAAA2pRmBdY1a9akf//+ufjii1NTU7PZ+ptvvjm33XZbLrnkktx7773p2bNnTjnllKxe/b93jpx33nl59tlnc8stt+SWW27Js88+m8mTJxe3JwAAALQpzQqso0ePzqRJk/KJT3wie+zR9C0NDQ25/fbbc+aZZ+bYY49N//79M2PGjNTV1eXBBx9MkixatCiPPfZYLrvssgwePDiDBw/ON7/5zfzmN7/Jf/3XfxW/VwAAAOzydniW4FdeeSW1tbUZMWJE47KampocccQRmT9/fk488cTMnz8/nTp1ypAhQxq3GTp0aDp16pT58+enX79+7/gZ1dVV6d690462+rZ6exRaD1qLsQzwzlryGOmYTFthLFMmOxxYa2trkyS9e/dusrxXr15ZtmxZkmT58uXp2bNnqqqqGtdXVVWlZ8+eWb58+bt+Rn19Q1atWrOjrTbq3r1TofWgtRjLxSv6OZBA62rJY6RjMm2FsUxr2Np3MLMEAwAAUEo7HFgrlUqSbHamdMWKFY1nXXv37p2VK1emoaGhcX1DQ0NWrly52ZlZAAAASAoIrPvvv38qlUrmzp3buGz9+vV5+umnM3jw4CTJ4MGDs2bNmsyfP79xm/nz52fNmjWN2wAAAMDbNese1rq6urz00ktJkk2bNmXp0qV57rnn0q1bt+y7776ZMGFCbrzxxvTr1y99+/bNrFmz0qlTpxx33HFJkgMPPDCjRo3KpZdemssuuyxJcumll+aoo4561wmXAAAA2D01K7AuWLAgEyZMaHw9c+bMzJw5M+PGjcv06dNzxhlnZP369bnsssvy+uuvZ9CgQbntttvSuXPnxvdcc801ufzyy3PaaaclScaMGZNvfOMbBe8OAAAAbUWzAuuwYcOycOHCra6vqqrKxIkTM3HixK1u061bt3zrW9/a9g4BAADYLZklGAAAgFISWAEAACglgRUAAIBSElgBAAAoJYEVAACAUhJYAQAAKCWBFQAAgFISWAEAACildq3dAADAzrBuQ30qlS6F1Vu7fmNWv7G2sHoAvDuBFQBok2raV6fvlDmF1Vs8fWxWF1YNgOZwSTAAAAClJLACAABQSgIrAAAApSSwAgAAUEoCKwAAAKUksAIAAFBKAisAAACl5DmswC6tc9eO6binQxkAQFvkWx6wS+u4Z7v0nTKnsHqLp48trBYAADvGJcEAAACUksAKAABAKQmsAAAAlJLACgAAQCkJrAAAAJSSwAoAAEApCawAAACUksAKAABAKbUrosiYMWOyZMmSzZaPHj06N910U2bOnJnrr7++ybrevXvniSeeKOLjAQAAaIMKCaz33ntv6uvrG1/X1tZm/Pjx+eQnP9m47L3vfW/uuOOOxtfV1dVFfDQAAABtVCGBtWfPnk1e33vvvencuXOTwNquXbtUKpUiPg4AAIDdQCGB9e0aGhpy77335m//9m9TU1PTuPzll1/OyJEj06FDhwwaNCiTJk3KAQccUPTHAwAA0EYUHlifeOKJvPLKKznhhBMalw0cODDTpk1Lv379snLlysyaNSsnnnhiHnzwwfTo0eNda1ZXV6V7906F9VhdvUeh9aC1GMsALeudjrmOybQVxjJlUnhgveeee3LooYfmoIMOalw2evToJtsMGjQoRx99dGbPnp1TTjnlXWvW1zdk1ao1hfXYvXunQutBazGWk0qlS2u3AOxG3umY65hMW2Es0xq29p2u0MfarFixIr/+9a+bnF3dkr322ivve9/7snjx4iI/HgAAgDak0MB63333pX379hk7duw7brd+/fr86U9/MgkTAAAAW1XYJcF/nWxp7Nix2WuvvZqsmzFjRo466qjss88+WblyZb773e9mzZo1GTduXFEfDwAAQBtTWGD9t3/7tyxevDhXX331ZuteffXVTJo0KatWrUqPHj1y2GGH5Z577sl+++1X1McDAOxU6zbUv+t989tyX/3a9Ruz+o21O9oWQJtWWGD98Ic/nIULF25x3be//e2iPgYAoFXUtK9O3ylzCqu3ePrYrC6sGkDbVOg9rAAAAFAUgRUAAIBSElgBAAAoJYEVAACAUhJYAQAAKCWBFQAAgFISWAEAACglgRUAAIBSElgBAAAoJYEVAACAUmrX2g0Au4/OXTum454OOwAANI9vjkCL6bhnu/SdMqfQmounjy20HgAA5eGSYAAAAEpJYAUAAKCUBFYAAABKSWAFAACglARWAAAASklgBQAAoJQEVgAAAEpJYAUAAKCUBFYAAABKSWAFAACglARWAAAASklgBQAAoJQEVgAAAEpJYAUAAKCU2rV2AwAAu6N1G+pTqXQprN7a9Ruz+o21hdUDKAOBFQCgFdS0r07fKXMKq7d4+tisLqwaQDkUcknwzJkzM2DAgCY/I0aMaFzf0NCQmTNnZuTIkRk4cGBOOumkvPDCC0V8NAAAAG1UYWdY3/ve9+aOO+5ofF1dXd3475tvvjm33XZbpk+fnve+97254YYbcsopp+Thhx9O586di2oBAACANqSwSZfatWuXSqXS+NOzZ88kfzm7evvtt+fMM8/Msccem/79+2fGjBmpq6vLgw8+WNTHAwAA0MYUFlhffvnljBw5MmPGjMm5556bl19+OUnyyiuvpLa2tsklwjU1NTniiCMyf/78oj4eAACANqaQS4IHDhyYadOmpV+/flm5cmVmzZqVE088MQ8++GBqa2uTJL17927ynl69emXZsmXNql9dXZXu3TsV0er/r7dHofWgtRjLALyd3wkUwfcLyqSQwDp69OgmrwcNGpSjjz46s2fPzqBBg3a4fn19Q1atWrPDdf6qe/dOhdaD1rKrjeUiH98AwOZ2pd8JlNeu9v2CtmFr3xMLuyT47fbaa6+8733vy+LFi1OpVJIky5cvb7LNihUrNjvrCgAAAH+1UwLr+vXr86c//SmVSiX7779/KpVK5s6d22T9008/ncGDB++MjwcAAKANKOSS4BkzZuSoo47KPvvsk5UrV+a73/1u1qxZk3HjxqWqqioTJkzIjTfemH79+qVv376ZNWtWOnXqlOOOO66IjwcAAKANKiSwvvrqq5k0aVJWrVqVHj165LDDDss999yT/fbbL0lyxhlnZP369bnsssvy+uuvZ9CgQbnttts8gxUAAICtKiSwfvvb337H9VVVVZk4cWImTpxYxMcBAACwG9gp97ACAADAjhJYAQAAKCWBFQAAgFISWAEAACglgRUAAIBSElgBAAAoJYEVAACAUhJYAQAAKCWBFQAAgFISWAEAACildq3dAAAAO27dhvpUKl0Krbl2/casfmNtoTUBtoXACgDQBtS0r07fKXMKrbl4+tisLrQiwLZxSTAAAAClJLACAABQSgIrAAAApSSwAgAAUEoCKwAAAKUksAIAAFBKAisAAAClJLACAABQSu1auwGgOJ27dkzHPYv7b712/casfmNtYfUAAGBbCKzQhnTcs136TplTWL3F08dmdWHVAABg27gkGAAAgFIS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njw548aNy4MPPpgbbrghixYtyte+9rUW7pzdVZu7h/Xzn/98BgwYkKlTpzYuO+aYY3LsscfmvPPO22z7q6++Or/61a/yy1/+snHZxRdfnBdffDE//vGPW6Rn+L+2dRxvyec+97kcfvjhmTJlys5qE97V9o7lc845JwcddFAaGhryyCOP5MEHH2yJdmGrtnUsP/744/nqV7+aX/3qV+nZs2dLtgrvaFvH8q233pof/vCH+c1vftO47Kc//WmmTp2a+fPnt0jP7N7a1BnWt956K88880xGjBjRZPmIESO2+h/q3//93zfbfuTIkVmwYEE2bNiw03qFrdmecbwldXV16dq1a9HtQbNt71i+8847s3z58px99tk7u0Volu0Zy//8z/+cQw89NN///vfzkY98JMccc0ymTp2aurq6lmgZtmh7xvKQIUNSW1ubX//612loaMjKlSvz0EMP5SMf+UhLtAxtK7C+9tprqa+vT+/evZss79Wr11avs1++fHl69erVZFnv3r2zcePGvPbaazutV9ia7RnH/9edd96ZV199NZ/5zGd2RovQLNszlhcuXJgbbrghV199daqrq1uiTXhX2zOWX3755cybNy9//OMfM3PmzFxyySV57LHHcuGFF7ZEy7BF2zOWBw8enGuvvTZf+9rXcsghh2T48OFpaGjIjBkzWqJlaFuBFUgeeeSRXHXVVbnmmms845hdyltvvZVzzz03kydPzgEHHNDa7cAOaWhoSFVVVa655poMGjQoo0aNyiWXXJJHHnkky5cvb+32oNlefPHFXH755fnKV76Sn/70p7nllltSW1ubb3zjG63dGruJdq3dQJF69OiR6urqzX4RrFixIpVKZYvv6d27d1asWNFk2fLly9OuXbv06NFjp/UKW7M94/ivHn744VxwwQWZMWNGxowZszPbhHe1rWN52bJlWbRoUS666KJcdNFFSZJNmzaloaEhH/zgB3PTTTdl5MiRLdI7vN32HJcrlUr69OmTLl26NC478MADkyRLly7d7AwXtITtGcs33nhjBg4cmNNPPz1JctBBB6Vjx4754he/mEmTJuU973nPTu+b3VubOsPaoUOHHHzwwZk7d26T5XPnzs3gwYO3+J7DDjtsi9sfcsghad++/U7rFbZme8Zx8pdZ/yZPnpxp06blE5/4xM5uE97Vto7lPn365IEHHsjs2bMbf0488cT8zd/8TeNMltAatue4PGTIkCxbtqzJPauLFy9OEle/0Gq2ZyyvW7dus1s0/vp606ZNO6dReJs2FViT5JRTTsn999+fn/zkJ1m0aFGmTp2aZcuW5cQTT0ySTJ48OZMnT27c/sQTT8yf//znXHHFFVm0aFF+8pOf5P7778+pp57aWrsA2zyO58yZk/PPPz/nnXdejjjiiNTW1qa2tjarVq1qpT2Av9iWsdy+ffv079+/yU+vXr3SoUOH9O/fP3vttVdr7gq7uW09Lh933HHp3r17LrzwwrzwwguZN29errjiihx77LGbzZ0BLWlbx/JRRx2VRx99NHfddVfjvdlTp07NwQcfnH333be1doPdSJu6JDhJPvWpT+W1117LrFmzsmzZsvTv3z833XRT418z/+d//qfJ9gcccEBuuummTJs2LXfffXf23nvvXHzxxTn22GNbo31Isu3j+Ec/+lE2btyYK6+8MldeeWXj8g996EO54447WrR3eLttHctQVts6lvfaa69873vfy9SpU/O5z30uXbt2zdFHH93sR5PBzrKtY3n8+PGpq6vLnXfemRkzZqRLly4ZNmxYzj///NZon91Qm3sOKwAAAG1Dm7skGAAAgLZBYAUAAKCUBFYAAABKSWAFAACglARWAAAASklgBQAAoJQEVgAAAEpJYAUAAKCUBFYAAABK6f8Bv5pAeXzBhtoAAAAASUVORK5CYII=\n",
      "text/plain": [
       "<Figure size 1152x432 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Reinitialize using the same entropy\n",
    "rs = np.random.RandomState(entropy)\n",
    "\n",
    "bs = StationaryBootstrap(opt.loc[\"Mkt-RF\", \"stationary\"], excess_market, random_state=rs)\n",
    "results = bs.apply(sharpe_ratio, 2500)\n",
    "SR = pd.DataFrame(results[:, -1:], columns=['SR'])\n",
    "fig = SR.hist(bins=40)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Probit (statsmodels)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The second example makes use of a Probit model from statsmodels.  The demo data is university admissions data which contains a binary variable for being admitted, GRE score, GPA score and quartile rank. This data is downloaded from the internet and imported using pandas."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "            admit         gre         gpa       rank\n",
      "count  400.000000  400.000000  400.000000  400.00000\n",
      "mean     0.317500  587.700000    3.389900    2.48500\n",
      "std      0.466087  115.516536    0.380567    0.94446\n",
      "min      0.000000  220.000000    2.260000    1.00000\n",
      "25%      0.000000  520.000000    3.130000    2.00000\n",
      "50%      0.000000  580.000000    3.395000    2.00000\n",
      "75%      1.000000  660.000000    3.670000    3.00000\n",
      "max      1.000000  800.000000    4.000000    4.00000\n"
     ]
    }
   ],
   "source": [
    "import arch.data.binary\n",
    "\n",
    "binary = arch.data.binary.load()\n",
    "binary = binary.dropna()\n",
    "print(binary.describe())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Fitting the model directly"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The first steps are to build the regressor and the dependent variable arrays.  Then, using these arrays, the model can be estimated by calling `fit`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Const   -3.003536\n",
      "gre      0.001643\n",
      "gpa      0.454575\n",
      "dtype: float64\n"
     ]
    }
   ],
   "source": [
    "import statsmodels.api as sm\n",
    "\n",
    "endog = binary[['admit']]\n",
    "exog = binary[['gre', 'gpa']]\n",
    "const = pd.Series(np.ones(exog.shape[0]), index=endog.index)\n",
    "const.name = 'Const'\n",
    "exog = pd.DataFrame([const, exog.gre, exog.gpa]).T\n",
    "\n",
    "# Estimate the model\n",
    "mod = sm.Probit(endog, exog)\n",
    "fit = mod.fit(disp=0)\n",
    "params = fit.params\n",
    "print(params)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### The wrapper function"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Most models in statsmodels are implemented as classes, require an explicit call to `fit` and return a class containing parameter estimates and other quantities.  These classes cannot be directly used with the bootstrap methods.  However, a simple wrapper can be written that takes the data as the only inputs and returns parameters estimated using a Statsmodel model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "def probit_wrap(endog, exog):\n",
    "    return sm.Probit(endog, exog).fit(disp=0).params"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A call to this function should return the same parameter values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Const   -3.003536\n",
       "gre      0.001643\n",
       "gpa      0.454575\n",
       "dtype: float64"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "probit_wrap(endog, exog)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The wrapper can be directly used to estimate the parameter covariance or to construct confidence intervals."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "          Const           gre       gpa\n",
      "Const  0.398367 -6.746728e-05 -0.103446\n",
      "gre   -0.000067  4.368570e-07 -0.000056\n",
      "gpa   -0.103446 -5.622006e-05  0.040041\n"
     ]
    }
   ],
   "source": [
    "from arch.bootstrap import IIDBootstrap\n",
    "\n",
    "bs = IIDBootstrap(endog=endog, exog=exog)\n",
    "cov = bs.cov(probit_wrap, 1000)\n",
    "cov = pd.DataFrame(cov, index=exog.columns, columns=exog.columns)\n",
    "print(cov)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Const    0.631163\n",
      "gre      0.000661\n",
      "gpa      0.200102\n",
      "dtype: float64\n",
      "T-stats\n",
      "Const   -4.758734\n",
      "gre      2.485109\n",
      "gpa      2.271720\n",
      "dtype: float64\n"
     ]
    }
   ],
   "source": [
    "se = pd.Series(np.sqrt(np.diag(cov)), index=exog.columns)\n",
    "print(se)\n",
    "print('T-stats')\n",
    "print(params / se)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "          Const       gre       gpa\n",
      "Lower -4.155903  0.000411  0.032858\n",
      "Upper -1.574994  0.002850  0.815272\n"
     ]
    }
   ],
   "source": [
    "ci = bs.conf_int(probit_wrap, 1000, method='basic')\n",
    "ci = pd.DataFrame(ci, index=['Lower', 'Upper'], columns=exog.columns)\n",
    "print(ci)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Speeding things up"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Starting values can be provided to `fit` which can save time finding starting values.  Since the bootstrap parameter estimates should be close to the original sample estimates, the full sample estimated parameters are reasonable starting values.  These can be passed using the `extra_kwargs` dictionary to a modified wrapper that will accept a keyword argument containing starting values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "def probit_wrap_start_params(endog, exog, start_params=None):\n",
    "    return sm.Probit(endog, exog).fit(start_params=start_params, disp=0).params"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "          Const           gre       gpa\n",
      "Const  0.398367 -6.746728e-05 -0.103446\n",
      "gre   -0.000067  4.368570e-07 -0.000056\n",
      "gpa   -0.103446 -5.622006e-05  0.040041\n"
     ]
    }
   ],
   "source": [
    "bs.reset()  # Reset to original state for comparability\n",
    "cov = bs.cov(\n",
    "    probit_wrap_start_params,\n",
    "    1000,\n",
    "    extra_kwargs={'start_params': params.values})\n",
    "cov = pd.DataFrame(cov, index=exog.columns, columns=exog.columns)\n",
    "print(cov)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Bootstrapping Uneven Length Samples\n",
    "Independent samples of uneven length are common in experiment settings, e.g., A/B testing of a website.  The `IIDBootstrap` allows for arbitrary dependence within an observation index and so cannot be naturally applied to these data sets. The `IndependentSamplesBootstrap` allows datasets with variables of different lengths to be sampled by exploiting the independence of the values to separately bootstrap each component. Below is an example showing how a confidence interval can be constructed for the difference in means of two groups. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[0.1991302 ]\n",
      " [0.51317728]]\n"
     ]
    }
   ],
   "source": [
    "from arch.bootstrap import IndependentSamplesBootstrap\n",
    "\n",
    "\n",
    "def mean_diff(x, y):\n",
    "    return x.mean() - y.mean()\n",
    "\n",
    "\n",
    "rs = np.random.RandomState(0)\n",
    "treatment = 0.2 + rs.standard_normal(200)\n",
    "control = rs.standard_normal(800)\n",
    "\n",
    "bs = IndependentSamplesBootstrap(treatment, control, random_state=rs)\n",
    "print(bs.conf_int(mean_diff, method='studentized'))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
