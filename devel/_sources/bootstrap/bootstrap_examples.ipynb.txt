{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Bootstrap Examples"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "_This setup code is required to run in an IPython notebook_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn\n",
    "\n",
    "seaborn.set_style(\"darkgrid\")\n",
    "plt.rc(\"figure\", figsize=(16, 6))\n",
    "plt.rc(\"savefig\", dpi=90)\n",
    "plt.rc(\"font\", family=\"sans-serif\")\n",
    "plt.rc(\"font\", size=14)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Sharpe Ratio"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The Sharpe Ratio is an important measure of return per unit of risk.  The example shows how to estimate the variance of the Sharpe Ratio and how to construct confidence intervals for the Sharpe Ratio using a long series of U.S. equity data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import arch.data.frenchdata\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "\n",
    "ff = arch.data.frenchdata.load()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The data set contains the Fama-French factors, including the excess market return."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "            Mkt-RF          SMB          HML           RF\n",
      "count  1109.000000  1109.000000  1109.000000  1109.000000\n",
      "mean      0.659946     0.206555     0.368864     0.274220\n",
      "std       5.327524     3.191132     3.482352     0.253377\n",
      "min     -29.130000   -16.870000   -13.280000    -0.060000\n",
      "25%      -1.970000    -1.560000    -1.320000     0.030000\n",
      "50%       1.020000     0.070000     0.140000     0.230000\n",
      "75%       3.610000     1.730000     1.740000     0.430000\n",
      "max      38.850000    36.700000    35.460000     1.350000\n"
     ]
    }
   ],
   "source": [
    "excess_market = ff.iloc[:, 0]\n",
    "print(ff.describe())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The next step is to construct a function that computes the Sharpe Ratio.  This function also return the annualized mean and annualized standard deviation which will allow the covariance matrix of these parameters to be estimated using the bootstrap."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "def sharpe_ratio(x):\n",
    "    mu, sigma = 12 * x.mean(), np.sqrt(12 * x.var())\n",
    "    values = np.array([mu, sigma, mu / sigma]).squeeze()\n",
    "    index = [\"mu\", \"sigma\", \"SR\"]\n",
    "    return pd.Series(values, index=index)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The function can be called directly on the data to show full sample estimates."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "mu        7.919351\n",
       "sigma    18.455084\n",
       "SR        0.429115\n",
       "dtype: float64"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "params = sharpe_ratio(excess_market)\n",
    "params"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Reproducibility\n",
    "\n",
    "All bootstraps accept the keyword argument `random_state` which can contain a NumPy `RandomState` instance. This allows the same pseudo random values to be used across multiple runs."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### _Warning_\n",
    "\n",
    "_The bootstrap chosen must be appropriate for the data.  Squared returns are serially correlated, and so a time-series bootstrap is required._"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Bootstraps are initialized with any bootstrap specific parameters and the data to be used in the bootstrap.  Here the `12` is the average window length in the Stationary Bootstrap, and the next input is the data to be bootstrapped."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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rR97/fXXo2fPngIqAAAAjdKob1LPOeecT9znP/7jP+K0006LI488sn6ssrIy8vPz4+KLL45169ZFr1694pprromKiopP3zEAAAA5q0kPTtqfv/zlL/Hcc8/FI4880mD89ddfjx07dsTVV18d3bt3j0WLFsX5558fv/zlL6Nnz577rZefnxelpR2z0Vrk57fLWi1oSeYubc1H5+vBMH/f310XZWWdPnnHJtTLz1o1MnEwzF9yk7lLrshKSH388cfjc5/73D7fkM6ePTtqa2ujpKQkIiJmzpwZL730UixdujQuv/zy/darq0vH9u27stFalJZ2zFotaEnmLs0lm8Hqoz46XzOdv83VYzZ1KMiPI6Yvz1q9DbPGRFXVe1mrx6fn/EtbZe7Slhzo/+uzElKfe+65OO200/YZLygoaHA/al5eXpSXl8df//rXbBwWAACAHNOoBycdSDqdjrVr18bQoUP32XbmmWfG/fffX/9679698dprr0V5eXmmhwUAACAHZfxN6ltvvRU7d+6Mvn377rPtpJNOirlz50a/fv3isMMOi3nz5sXf//73GD9+fKaHBQAAIAdlHFLffffdiIjo3LnzPtsmTZoUe/fujRtuuCG2bdsWFRUVMW/evAa/rQpA2/dxDxFqC/eVAgDJ0+SQ+tprrzV4XVFRsc/Yh/Lz82PKlCkxZcqUT9cdAG1CczxECAA4OGV8TyoAAABki5AKAABAYgipAAAAJIaQCgAAQGIIqQAAACSGkAoAAEBiCKkAAAAkhpAKAABAYgipAAAAJIaQCgAAQGIIqQAAACSGkAoAAEBitG/tBgA4sJJDiqO4yOkaADg4uOoBSLjiovZxxPTlWau3YdaYrNUCAMg2y30BAABIDCEVAACAxBBSAQAASAwhFQAAgMQQUgEAAEgMIRUAAIDEEFIBAABIDCEVAACAxBBSAQAASAwhFQAAgMQQUgEAAEgMIRUAAIDEaN/aDQAAEe/vrouysk5Zq1dTuyeqd9RkrR4AtBQhFQASoENBfhwxfXnW6m2YNSaqs1YNAFpOk5b7plKpOP300+P555+vH7vuuuuiX79+Df7mzZtXv33FihXxla98JSoqKmLChAmxcePGrDUPAABAbmn0N6m1tbUxderUWL9+fYPxysrKmDZtWowdO7Z+rKSkJCIi3n777Zg0aVJMnjw5Tj755Ljnnnti8uTJ8dhjj0W7dm6HBQAAoKFGJcXKysr4t3/7t9i0adM+2954440YOHBglJWV1f8VFxdHRMSiRYuif//+cckll0SfPn3i5ptvjrfffjtWrFiR3U8BAABATmhUSF21alUMHz48Hn300QbjVVVVsX379ujVq9fHvm/NmjUxdOjQ+tfFxcUxYMCAWL16dQYtAwAAkKsatdz3nHPO+djxysrKaN++fdx5553x3HPPxaGHHhoXXHBBjBs3LiI+CLHdunVr8J4uXbrEli1bDni8/Py8KC3t2JjWPlF+frus1YKWZO4CmXIO+XScf2mrzF1yRUZP933jjTciIqJ///4xYcKEWLlyZVx//fVRXFwco0aNipqamigsLGzwnsLCwkilUgesW1eXju3bd2XSWr3S0o5ZqwUtydzlQ9n8WRIOLs4hn47zL22VuUtbcqDrm4xC6rnnnhtjxoyJ0tLSiPggrG7cuDEWLlwYo0aNiqKion0CaSqVqt8fAAAAPiqjR+zm5eXtEzjLy8vrl/N27949qqqqGmzfunVrlJWVZXJYAAAAclRGIXXWrFlx6aWXNhhbt25dlJeXR0RERUVFvPTSS/Xbampq4pVXXolBgwZlclgAAAByVEYhdcSIEfHcc8/Fww8/HJs2bYoFCxbE0qVL46KLLoqIiPHjx8eaNWvi3nvvjcrKyvjud78bPXr0iOOOOy4rzQMAAJBbMgqpw4YNi9mzZ8eiRYtizJgxsWDBgrj99tvj2GOPjYiInj17xl133RXLli2L8ePHx9atW2POnDnRrl1GhwUAACBHNfnBSa+99lqD16NHj47Ro0fvd/8TTzwxTjzxxKZ3BgB8au/vrsvqk6FravdE9Y6arNUDgP3J6Om+AEAydSjIjyOmL89avQ2zxkR11qoBwP5ZdwsAAEBiCKkAAAAkhpAKAABAYgipAAAAJIaQCgAAQGIIqQAAACSGkAoAAEBiCKkAAAAkhpAKAABAYrRv7QYAck3JIcVRXOT0CgDwabiKAsiy4qL2ccT05Vmrt2HWmKzVAgBIOst9AQAASAwhFQAAgMQQUgEAAEgMIRUAAIDEEFIBAABIDCEVAACAxBBSAQAASAwhFQAAgMQQUgEAAEgMIRUAAIDEEFIBAABIDCEVAACAxBBSAQAASAwhFQAAgMQQUgEAAEiMJoXUVCoVp59+ejz//PP1Yy+88EKMHz8+Bg8eHCNHjoyf//znDd4zcuTI6NevX4O/devWZad7AAAAckr7xu5YW1sbU6dOjfXr19ePbdiwIS699NKYPHlyjBo1KtasWRPf/e53o0uXLjFixIhIpVKxefPmWLhwYRx22GH17zv00EOz+ykAAADICY0KqZWVlTF16tRIp9MNxn/1q1/FUUcdFZdddllERBx++OHxhz/8IR577LEYMWJEvPHGG5GXlxef//zno6CgIPvdAwAAkFMatdx31apVMXz48Hj00UcbjI8aNSquu+66BmN5eXlRW1sbERGvv/569OzZU0AFAACgURr1Teo555zzseO9evVq8Hrr1q2xfPnyuPzyyyPig29g8/Pz4+KLL45169ZFr1694pprromKiooM2wYAACAXNfqe1E+ya9euuPzyy6Nbt271ofb111+PHTt2xNVXXx3du3ePRYsWxfnnnx+//OUvo2fPnvutlZ+fF6WlHbPSV35+u6zVgpZk7gJJc7Cck5x/aavMXXJFVkLqe++9F5deemn8+c9/jp/97GdRXFwcERGzZ8+O2traKCkpiYiImTNnxksvvRRLly6t/7b149TVpWP79l3ZaC1KSztmrRa0JHO37Sor69TaLUCzOFjOSc6/tFXmLm3Jga6XMg6p27Zti4suuii2bt0aDz/8cHzuc5+r31ZQUNDgftS8vLwoLy+Pv/71r5keFgAAgBzUpN9J/UepVCouu+yy+Nvf/hYLFiyI8vLyBtvPPPPMuP/+++tf7927N1577bV99gMAAICIDL9JnTdvXvzpT3+KH//4x1FcXBxVVVUR8cE3qKWlpXHSSSfF3Llzo1+/fnHYYYfFvHnz4u9//3uMHz8+K80DAACQWzIKqY8//njs2bMnLrjgggbjxxxzTCxcuDAmTZoUe/fujRtuuCG2bdsWFRUVMW/evOjUyf1aAAAA7KvJIfW1116r/99Lliw54L75+fkxZcqUmDJlStM7AwAA4KCT0T2pAAAAkE1Z+51UgLaq5JDiKC5yOgQASAJXZcBBr7iofRwxfXnW6m2YNSZrtQAADjaW+wIAAJAYQioAAACJIaQCAACQGEIqAAAAiSGkAgAAkBhCKgAAAIkhpAIAAJAYQioAAACJIaQCAACQGO1buwEAIPne310XZWWdslqzpnZPVO+oyWpNANo+IRUA+EQdCvLjiOnLs1pzw6wx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yVo9gCQQUgEAWkiHgvysPvBuw6wxUZ21agDJYLkvAAAAiSGkAgAAkBhCKgAAAIkhpAIAAJAYHpwEANBGeVowkIuEVACANsrTgoFcZLkvAAAAiSGkAgAAkBhCKgAAAIkhpAIAAJAYQioAAACJIaQCAACQGEIqAAAAiSGkAgAAkBhCKgAAAIkhpAIAAJAYQioAAACJ0b61GwAAIBne310XZWWdslavpnZPVO+oyVo94OAgpAIAEBERHQry44jpy7NWb8OsMVGdtWrAwcJyXwAAABIj45C6adOmuOyyy2Lo0KHxL//yLzFr1qyora2NiIjrrrsu+vXr1+Bv3rx5mR4SAACAHJXRct9UKhWXXXZZ9OnTJx555JF49913Y8aMGRERMX369KisrIxp06bF2LFj699TUlKSWccAAADkrIy+SV27dm1s2rQpbrnllujdu3cMGzYsrrzyynjsscciIuKNN96IgQMHRllZWf1fcXFxVhoHAAAg92QUUsvLy+P++++Pz3zmM/VjeXl5kUqloqqqKrZv3x69evXKuEkAAAAODhmF1M9+9rNx/PHH17/eu3dvzJ8/P4YMGRKVlZXRvn37uPPOO+OEE06IsWPHxpIlSzJuGAAAgNyV1Z+gueWWW2LdunWxePHiWLlyZURE9O/fPyZMmBArV66M66+/PoqLi2PUqFEHrJOfnxelpR2z0lN+frus1YKWZO4CkAv8f1nLce1ArshKSE2n03HTTTfFwoUL484774y+fftGnz59YsyYMVFaWhoRH4TVjRs3xsKFCz8xpNbVpWP79l3ZaC1KSztmrRa0pMbM3Wz+4DoANAfXYS3HdS9tyYGuYzP+CZq9e/fGjBkz4pFHHok77rgjTjnllIj44N7UDwPqh8rLy2PLli2ZHhIAAIAclXFInTVrVjz22GNx1113xWmnndZg/NJLL22w77p166K8vDzTQwIAAJCjMlru+/LLL8dPfvKTmDp1agwcODCqqqrqt40YMSLOP//8ePjhh+Okk06K3/72t7F06dKYN29epj0DAACQozIKqb/+9a8jImL27Nkxe/bsBtv+9Kc/xezZs2POnDlx2223xWGHHRa33357HHvssZkcEgAAgByWUUj9zne+E9/5znf2u3306NExevToTA4BAADAQSSrP0EDHFjJIcVRXNT4f3ae3gsAwMFGSIUWVFzUPo6Y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\n",
      "text/plain": [
       "<Figure size 1152x432 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "from arch.bootstrap import StationaryBootstrap\n",
    "\n",
    "# Initialize with entropy from random.org\n",
    "entropy = [877788388, 418255226, 989657335, 69307515]\n",
    "rs = np.random.RandomState(entropy)\n",
    "\n",
    "bs = StationaryBootstrap(12, excess_market, random_state=rs)\n",
    "results = bs.apply(sharpe_ratio, 2500)\n",
    "SR = pd.DataFrame(results[:, -1:], columns=[\"SR\"])\n",
    "fig = SR.hist(bins=40)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "             mu     sigma        SR\n",
      "mu     3.835234 -0.700250  0.222532\n",
      "sigma -0.700250  3.517844 -0.119008\n",
      "SR     0.222532 -0.119008  0.014912\n",
      "\n",
      "\n",
      "mu       1.958375\n",
      "sigma    1.875592\n",
      "SR       0.122114\n",
      "Name: Std Errors, dtype: float64\n"
     ]
    }
   ],
   "source": [
    "cov = bs.cov(sharpe_ratio, 1000)\n",
    "cov = pd.DataFrame(cov, index=params.index, columns=params.index)\n",
    "print(cov)\n",
    "se = pd.Series(np.sqrt(np.diag(cov)), index=params.index)\n",
    "se.name = \"Std Errors\"\n",
    "print(\"\\n\")\n",
    "print(se)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "              mu      sigma        SR\n",
      "Lower   4.319805  14.559092  0.186293\n",
      "Upper  12.004185  21.517835  0.660455\n"
     ]
    }
   ],
   "source": [
    "ci = bs.conf_int(sharpe_ratio, 1000, method=\"basic\")\n",
    "ci = pd.DataFrame(ci, index=[\"Lower\", \"Upper\"], columns=params.index)\n",
    "print(ci)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Alternative confidence intervals can be computed using a variety of methods.  Setting `reuse=True` allows the previous bootstrap results to be used when constructing confidence intervals using alternative methods."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "              mu      sigma        SR\n",
      "Lower   3.834517  15.392333  0.197774\n",
      "Upper  11.518896  22.351076  0.671937\n"
     ]
    }
   ],
   "source": [
    "ci = bs.conf_int(sharpe_ratio, 1000, method=\"percentile\", reuse=True)\n",
    "ci = pd.DataFrame(ci, index=[\"Lower\", \"Upper\"], columns=params.index)\n",
    "print(ci)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Optimal Block Length Estimation\n",
    "\n",
    "The function `optimal_block_length` can be used to estimate the optimal block lengths for the Stationary and Circular bootstraps. Here we use the squared market return since the Sharpe ratio depends on the mean and the variance, and the autocorrelation in the squares is stronger than in the returns."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "        stationary   circular\n",
      "Mkt-RF   47.766787  54.679322\n"
     ]
    }
   ],
   "source": [
    "from arch.bootstrap import optimal_block_length\n",
    "\n",
    "opt = optimal_block_length(excess_market ** 2)\n",
    "print(opt)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can repeat the analysis above using the estimated optimal block length.  Here we see that the extremes appear to be slightly more extreme."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAA6kAAAF7CAYAAAAwts2+AAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjMuNCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8QVMy6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAtGUlEQVR4nO3de5RWdb0/8PcwzMAY6BgOnOPBVMQ7NSjKSs2fl0wDjBI0PZblpbyQ4TK8oOalXCpLQ5epWBpqhqlEHj1Gx1yWZSclUxE7eTmMFyBTGzRCZGS4PL8//Dm/JgRnnGdmNsPrtdas5fPdez77s9f6uud58+znuytKpVIpAAAAUAC9ursBAAAAeJeQCgAAQGEIqQAAABSGkAoAAEBhCKkAAAAUhpAKAABAYfTu7gYAoKdraGjI9ddfn9///vdZsmRJNttss+y+++45/vjjs9tuuyVJ7rrrrpxzzjlr/W51dXW22GKL7LPPPvnGN76RD3/4w13dPgB0KSEVADrR/Pnzc+SRR2aXXXbJWWedlbq6ujQ2NubOO+/MF77whVx33XU54IADWva/6qqrMnDgwJbXb731Vp544olMnz49DQ0NueOOO7rjNACgywipANCJbr755vTr1y833XRTqqurW8Y//elPZ9y4cbnyyitbhdRdd901W2+9dasa++23X1avXp0bb7wxDQ0NGTp0aJf1DwBdTUgFgE70+uuvp6KiYq3x6urqnHnmmVmwYEGb6my66ablbg0ACklIBYBOdOCBB+bXv/51jjzyyBx++OH5+Mc/nu222y7JO5+Q/rPVq1dn1apVLa/ffPPN/P73v8/06dPzsY99LEOGDOmy3gGgOwipANCJjjzyyDQ2NuYHP/hBvv3tbydJNt988+y111458sgj8/GPf7zV/qNGjVqrRm1tbT75yU/mjDPOSK9eFuYHoGerKJVKpe5uAgB6umXLluV3v/td5syZk0cffTQNDQ1JkuOPPz5nn312y+q+1113XQYNGpRVq1bl5z//eW677baceuqpmTBhQjefAQB0DZ+kAkAX6NevXw455JAccsghSZIXXngh3/zmN3PTTTflsMMOa9lv++23b1k4abfddkt1dXWuvvrq9OnTJyeccEK39A4AXck9QwDQSV599dXstddeue2229baNmTIkJx77rlJ0vKp6ns57bTTst122+Wqq67K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IaQCAABQGEIqAAAAhSGkAgAAUBhCKgAAAIUhpAIAAFAYQioAAACFIaQCAABQGL27uwHgg+u3aU1q+pT3f+OmFauybGlTWWsCAEBbCamwAavp0zvbTJ5d1povTRmTZWWtCAAAbed2XwAAAApDSAUAAKAw3O4LAECnsHYC8EEIqQAAdAprJwAfhJAKtPL2ytWpq+vf3W0AALCR6nBIXbhwYS699NI8/vjjqampyejRo3P66aenT58+Of/88zNz5sxW+59zzjk59thjO3pYoJP0raos6796vzRlTNlqAQDQ83UopDY3N+fkk0/O0KFDc8cdd+T111/PueeemySZPHlyGhoactZZZ2Xs2LEtv9OvX7+OdQwAAECP1aHVfZ966qksXLgwl112WbbbbruMHDkyp512Wu69994kyQsvvJBhw4alrq6u5aempqYsjQMAANDzdCikDhkyJDfccEM+9KEPtYxVVFSkubk5jY2NWbJkSbbddtsONwkAAMDGoUMh9cMf/nD23nvvltdr1qzJjBkzMmLEiDQ0NKR37965+uqrs++++2bs2LG56667OtwwAAAAPVdZV/e97LLL8swzz2TWrFl59NFHkyQ77bRTjjnmmDz66KO54IILUlNTk1GjRq23TmVlRWprNylbX5WVvcpaD7qLuQxAZ9pQVnj3t7D8vMegSMoSUkulUi655JLcfvvtufrqq7P99ttn6NChGTNmTGpra5O8E1YXLFiQ22+//X1D6urVpSxZsrwcrSV550JWznrQXf55Lm8IbyQA2HBsKCu8e19Xft4v09XW9z62Q7f7Ju/c4nvuuefmjjvuyFVXXZWDDjooyTvfTX03oL5ryJAhee211zp6SAAAAHqoDofUKVOm5N57780111yTgw8+uNX4SSed1GrfZ555JkOGDOnoIQEAAOihOnS775NPPpkf/vCHmTRpUoYNG5bGxsaWbQceeGC+/OUv59Zbb83++++f3/72t7n77rtzyy23dLRnAAAAeqgOhdRf/OIXSZKpU6dm6tSprbb96U9/ytSpUzNt2rRcccUV2WqrrXLllVdmjz326MghAQAA6ME6FFLPPvvsnH322evcPnr06IwePbojhwAAgBblXoG4acWqLFvaVLZ6QMeV9RE0AADQmTpjBeJlZasGlEOHF04CAACAchFSAQAAKAwhFQAAgMIQUgEAACgMIRUAAIDCEFIBAAAoDCEVAACAwhBSAQAAKIze3d0AbEz6bVqTmj4d+9+urq5/mboBAN5eubqsf1vfXrk6fasqy1YvSZpWrMqypU1lrQlFJqRCF6rp0zvbTJ5dtnovTRlTtloAsDHqW1VZ9r/N5az3bs1lZa0IxeZ2XwAAAApDSAUAAKAwhFQAAAAKQ0gFAACgMCycBOtRjtV4AQCAtvPuG9bDarwAANC13O4LAABAYQipAAAAFIaQCgAAQGEIqQAAABSGkAoAAEBhWN2XHsPjYgCAnujtlatTV9e/bPWaVqzKsqVNZasH5eYdPT1GuR8Xk3hkDADQ/fpWVZb9kXjLylYNyk9IBQAAPrDOuJvNp70bNyEVAAD4wDrrbjaf9m68LJwEAABAYXT6J6nNzc25+OKLc99996W6ujrHHntsvvrVr3b2YQEAgPewroWYyrk4E3REp4fUyy+/PHPnzs3NN9+cV199NWeddVa23HLLjBljQRoAAOhqnbEQE5RTp4bU5cuXZ+bMmfne976XYcOGZdiwYfnKV76SGTNmCKkAAMAGqdyLRVkoqrVODanPPvtsmpubM2LEiJaxESNGZNq0aVm1alV6995w123aGCdmuc/57ZWr07eqsmz1AADoGYr+bNhyLxb17MWfLvvt1htCvliXTk2JjY2N2WyzzdKnT5+WsS222CIrV67MG2+8kYEDB3bm4TtVuSfmhrCCWWecs1tNAAD4Zxvbs2HLfb5J8c95fSpKpVKps4rffffdmTp1an7729+2jC1atCgHHXRQfvnLX2bw4MGddWgAAAA2QJ36CJo+ffqkubm51di7r2tqajrz0AAAAGyAOjWkDho0KEuXLm0VVBsbG1NdXZ3NNtusMw8NAADABqhTQ+rOO++cqqqqzJ07t2Xs8ccfz6677rpBL5oEAABA5+jUkFpTU5PPfe5z+da3vpWnnnoqv/zlL3PTTTflS1/6UmceFgAAgA1Upy6clCRNTU256KKLcv/99+dDH/pQjj/++Bx//PGdeUgAAAA2UJ0eUgEAAKCtOvV2367S3Nyc888/P3vuuWf22Wef3Hjjjevc99lnn82RRx6Z+vr6jBs3Lk899VQXdgrr1565/POf/zyHHnpohg8fnrFjx+ZXv/pVF3YK69eeufyuJUuWZO+9985dd93VBR1C27RnLj///PP50pe+lPr6+hxyyCH5xS9+0YWdwrq1Zx4/9thjGTduXIYPH57Pfvaz+e///u8u7BTe0SNC6uWXX565c+fm5ptvzre+9a1cf/31mT177YfhLl++PF/5yldSX1+fu+66KyNGjMhJJ52UZcs21Mfc0tO0dS4/9thjOeuss/KlL30p99xzTw4//PB8/etfz9NPP90NXcPa2jqX/9Gll16a119/vYs6hLZp61x+6623ctxxx+Vf/uVfcs899+QLX/hCJk2alIaGhm7oGlpr6zx+/fXXc/LJJ+fTn/50/vM//zOjRo3K1772tbz88svd0DUbtdIG7q233ip99KMfLf3ud79rGbvuuutKRx111Fr7/uQnPyntv//+pdWrV5dKpVJpzZo1pU996lOlmTNndlm/sC7tmcvnnntu6fTTT281dtxxx5WuuOKKTu8T3k975vK7fv3rX5cOOeSQ0sc//vHST3/6065oE95Xe+byjBkzSgcccECpubm5ZezEE0/0HoNu1555fP/995dGjBjRamzkyJGl2bNnd3qf8I82+E9Sn3322TQ3N2fEiBEtYyNGjMgf//jHrFq1qtW+8+bNy+67755evd457YqKiuy+++6tHpED3aU9c/mYY47JhAkTWo1VVFRkxYoVXdIrrE975nKSLFu2LBdddFEuvvjiVFVVdWWrsF7tmcu///3vc+CBB7aaw9///vdzxBFHdFm/8F7aM49ra2vz5ptv5r/+679SKpXywAMP5K233sqOO+7Y1W2zkdvgQ2pjY2M222yz9OnTp2Vsiy22yMqVK/PGG2+ste/AgQNbjQ0YMCCvvfZal/QK69OeubzTTjtl6NChLa/nz5+fRx55JHvuuWeX9Qvr0p65nCRXXHFF9t13X/OXwmnPXF64cGEGDBiQiy66KJ/4xCdy2GGH5cEHH+zqlmEt7ZnHe+yxR774xS/m9NNPz6677pqvfe1rufDCC7Pddtt1ddts5Db4kNrU1JTq6upWY+++bm5ubtO+/7wfdIf2zOV/9Prrr+fUU0/NiBEjctBBB3Vqj9AW7ZnLjz76aB588MGceeaZXdYftFV75vJbb72V6dOnZ9NNN80NN9zQ8l2+//mf/+myfuG9tGceL1++PH/+859zyimnZNasWTnjjDNy6aWX5sknn+yqdiFJ0ru7G+ioPn36rPU/2Luva2pq2rRv3759O7dJaIP2zOV3vfrqqzn++OPTq1evfPe73225lR26U1vn8ttvv51vfvObOf/889O/f/8u7RHaoj3X5crKyuywww75xje+kSTZZZdd8vjjj2fmzJkZNmxY1zQM76E983j69Olpbm7OaaedluSdedzQ0JDrr78+3//+97umYUgP+CR10KBBWbp0aav/+RobG1NdXZ3NNttsrX0bGxtbjS1evDh1dXVd0iusT3vmcpIsWrQoRx99dCoqKvKjH/0om2++eVe2C+vU1rn81FNPZcGCBTnrrLOy2267Zbfddstf//rXXHjhhbngggu6o3VopT3X5YEDB2bIkCGtxrbddtv85S9/6ZJeYV3aM4//+Mc/Zvvtt281tuuuu2bRokVd0iu8a4MPqTvvvHOqqqpaLX70+OOPZ9ddd03v3q0/KK6vr8/cuXNTKpWSJKVSKXPnzs3w4cO7smV4T+2Zy0uWLMlxxx2X/v3750c/+lG22GKLrm4X1qmtc/ljH/tY7r///tx9990tP1tssUUmTpzY8q/40J3ac13ebbfd1noMWENDQ/7t3/6tS3qFdWnPPB44cGCee+65VmPPP/98PvKRj3RJr/CuDT6k1tTU5HOf+1y+9a1v5amnnsovf/nL3HTTTfnSl76U5J1/KXr77beTJJ/+9KezfPnyXHzxxWloaMhll12WZcuWZfTo0d15CpCkfXP5qquuyt/+9rdMmTIlq1evTmNjYxobG/Pmm2925ylAkrbP5b59+2brrbdu9dOrV68MGDAgAwYM6OazgPZdl4888si8+OKLueKKK7Jw4cLccssteeSRR3LkkUd25ylAu+fxH/7wh9x4441ZtGhRfvKTn+Suu+7Kl7/85e48BTZG3fwInLJYvnx56ayzzioNHz68tM8++5SmT5/esm2HHXZo9cy9efPmlT73uc+Vhg0bVho/fnzpj3/8Y3e0DO+prXN55MiRpR122GGtn0mTJnVX69BKe67L/2jffff1nFQKpT1zee7cuaXx48eXhg0bVho1alTpgQce6I6WYS3tmce//vWvS4cddlhp+PDhpUMPPbR03333dUfLbOQqSqX/d+8rAAAAdLMN/nZfAAAAeg4hFQAAgMIQUgEAACgMIRUAAIDCEFIBAAAoDCEVAACAwhBSAQAAKAwhFQAAgMIQUgEAACiM/wsHFCDINWnnugAAAABJRU5ErkJggg==\n",
      "text/plain": [
       "<Figure size 1152x432 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Reinitialize using the same entropy\n",
    "rs = np.random.RandomState(entropy)\n",
    "\n",
    "bs = StationaryBootstrap(\n",
    "    opt.loc[\"Mkt-RF\", \"stationary\"], excess_market, random_state=rs\n",
    ")\n",
    "results = bs.apply(sharpe_ratio, 2500)\n",
    "SR = pd.DataFrame(results[:, -1:], columns=[\"SR\"])\n",
    "fig = SR.hist(bins=40)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Probit (statsmodels)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The second example makes use of a Probit model from statsmodels.  The demo data is university admissions data which contains a binary variable for being admitted, GRE score, GPA score and quartile rank. This data is downloaded from the internet and imported using pandas."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "            admit         gre         gpa       rank\n",
      "count  400.000000  400.000000  400.000000  400.00000\n",
      "mean     0.317500  587.700000    3.389900    2.48500\n",
      "std      0.466087  115.516536    0.380567    0.94446\n",
      "min      0.000000  220.000000    2.260000    1.00000\n",
      "25%      0.000000  520.000000    3.130000    2.00000\n",
      "50%      0.000000  580.000000    3.395000    2.00000\n",
      "75%      1.000000  660.000000    3.670000    3.00000\n",
      "max      1.000000  800.000000    4.000000    4.00000\n"
     ]
    }
   ],
   "source": [
    "import arch.data.binary\n",
    "\n",
    "binary = arch.data.binary.load()\n",
    "binary = binary.dropna()\n",
    "print(binary.describe())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Fitting the model directly"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The first steps are to build the regressor and the dependent variable arrays.  Then, using these arrays, the model can be estimated by calling `fit`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Const   -3.003536\n",
      "gre      0.001643\n",
      "gpa      0.454575\n",
      "dtype: float64\n"
     ]
    }
   ],
   "source": [
    "import statsmodels.api as sm\n",
    "\n",
    "endog = binary[[\"admit\"]]\n",
    "exog = binary[[\"gre\", \"gpa\"]]\n",
    "const = pd.Series(np.ones(exog.shape[0]), index=endog.index)\n",
    "const.name = \"Const\"\n",
    "exog = pd.DataFrame([const, exog.gre, exog.gpa]).T\n",
    "\n",
    "# Estimate the model\n",
    "mod = sm.Probit(endog, exog)\n",
    "fit = mod.fit(disp=0)\n",
    "params = fit.params\n",
    "print(params)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### The wrapper function"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Most models in statsmodels are implemented as classes, require an explicit call to `fit` and return a class containing parameter estimates and other quantities.  These classes cannot be directly used with the bootstrap methods.  However, a simple wrapper can be written that takes the data as the only inputs and returns parameters estimated using a Statsmodel model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "def probit_wrap(endog, exog):\n",
    "    return sm.Probit(endog, exog).fit(disp=0).params"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A call to this function should return the same parameter values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Const   -3.003536\n",
       "gre      0.001643\n",
       "gpa      0.454575\n",
       "dtype: float64"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "probit_wrap(endog, exog)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The wrapper can be directly used to estimate the parameter covariance or to construct confidence intervals."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "          Const           gre       gpa\n",
      "Const  0.416531 -5.957659e-05 -0.109445\n",
      "gre   -0.000060  3.975001e-07 -0.000051\n",
      "gpa   -0.109445 -5.139835e-05  0.040712\n"
     ]
    }
   ],
   "source": [
    "from arch.bootstrap import IIDBootstrap\n",
    "\n",
    "bs = IIDBootstrap(endog=endog, exog=exog)\n",
    "cov = bs.cov(probit_wrap, 1000)\n",
    "cov = pd.DataFrame(cov, index=exog.columns, columns=exog.columns)\n",
    "print(cov)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Const    0.645392\n",
      "gre      0.000630\n",
      "gpa      0.201772\n",
      "dtype: float64\n",
      "T-stats\n",
      "Const   -4.653818\n",
      "gre      2.605233\n",
      "gpa      2.252919\n",
      "dtype: float64\n"
     ]
    }
   ],
   "source": [
    "se = pd.Series(np.sqrt(np.diag(cov)), index=exog.columns)\n",
    "print(se)\n",
    "print(\"T-stats\")\n",
    "print(params / se)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "          Const       gre       gpa\n",
      "Lower -4.170693  0.000368  0.028639\n",
      "Upper -1.697383  0.002885  0.825660\n"
     ]
    }
   ],
   "source": [
    "ci = bs.conf_int(probit_wrap, 1000, method=\"basic\")\n",
    "ci = pd.DataFrame(ci, index=[\"Lower\", \"Upper\"], columns=exog.columns)\n",
    "print(ci)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Speeding things up"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Starting values can be provided to `fit` which can save time finding starting values.  Since the bootstrap parameter estimates should be close to the original sample estimates, the full sample estimated parameters are reasonable starting values.  These can be passed using the `extra_kwargs` dictionary to a modified wrapper that will accept a keyword argument containing starting values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "def probit_wrap_start_params(endog, exog, start_params=None):\n",
    "    return sm.Probit(endog, exog).fit(start_params=start_params, disp=0).params"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "          Const           gre       gpa\n",
      "Const  0.416531 -5.957659e-05 -0.109445\n",
      "gre   -0.000060  3.975001e-07 -0.000051\n",
      "gpa   -0.109445 -5.139835e-05  0.040712\n"
     ]
    }
   ],
   "source": [
    "bs.reset()  # Reset to original state for comparability\n",
    "cov = bs.cov(\n",
    "    probit_wrap_start_params, 1000, extra_kwargs={\"start_params\": params.values}\n",
    ")\n",
    "cov = pd.DataFrame(cov, index=exog.columns, columns=exog.columns)\n",
    "print(cov)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Bootstrapping Uneven Length Samples\n",
    "Independent samples of uneven length are common in experiment settings, e.g., A/B testing of a website.  The `IIDBootstrap` allows for arbitrary dependence within an observation index and so cannot be naturally applied to these data sets. The `IndependentSamplesBootstrap` allows datasets with variables of different lengths to be sampled by exploiting the independence of the values to separately bootstrap each component. Below is an example showing how a confidence interval can be constructed for the difference in means of two groups. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[0.1991302 ]\n",
      " [0.51317728]]\n"
     ]
    }
   ],
   "source": [
    "from arch.bootstrap import IndependentSamplesBootstrap\n",
    "\n",
    "\n",
    "def mean_diff(x, y):\n",
    "    return x.mean() - y.mean()\n",
    "\n",
    "\n",
    "rs = np.random.RandomState(0)\n",
    "treatment = 0.2 + rs.standard_normal(200)\n",
    "control = rs.standard_normal(800)\n",
    "\n",
    "bs = IndependentSamplesBootstrap(treatment, control, random_state=rs)\n",
    "print(bs.conf_int(mean_diff, method=\"studentized\"))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
